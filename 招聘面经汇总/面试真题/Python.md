# 对象的创建 销毁 生命周期
- 以下例⼦中， area 计算过程中有临时对象创建吗？为什么？ Python 如何优化临时对象创建效率
```
pi = 2
r = 2
area = p1*r**2
```
这个语句⾸先计算半径r的平⽅，中间结果由⼀个临时对象来保存，假设是t ； 然后计算圆周率pi与t的乘积，得到最终结果并赋值给变量area； 最后，销毁临时对象t 。\
为了提⾼浮点对象创建效率， Python引⼊了**空闲对象缓存池** 。浮点对象销毁后， Python 并不急于回收内存，⽽是将对象放⼊⼀个**空闲链表** 。 后续需要创建浮点对象时，先到空闲链表中取，省去分配内存的开销。
- 以下例⼦中，变量 e 的 id 值为何与已销毁的变量 pi 相同？
```
>>> pi = 3.14
>>> id(pi)
4565221808
>>> del pi
>>> e = 2.71
>>> id(e)
4565221808
```
例⼦中,pi 对象销毁后，Python先不回收对象内存，⽽是将其插空闲对象链表头部。当创建浮点对象e时，Python 从链表头取出空闲对象来⽤，省去了申请内存的开销。 换句话讲，pi对象销毁后被e重新利⽤了，因此id值相同也就不奇怪了。
- 解释以下程序运算结果
```
>>> a = 1 + 0
>>> b = 1 * 1
>>> id(a), id(b)
(4408209536, 4408209536)
>>> c = 1000 + 0
>>> d = 1000 * 1
>>> id(c), id(d)
(4410298224, 4410298160)
```
场景⼀ 由于 1 + 0 计算结果为 1 ，在⼩整数范围内， Python 直接从静态对象池中取出整数 1 ；1 * 1 也是同理。名字 a 和 b 其实都跟同⼀个对象绑定，即⼩整数对象池中的整数 1 ，因⽽ id相同。\
场景⼆ 1000 + 0 和 1000 * 1 计算结果都是 1000 ，但由于 1000 不在⼩整数范围内， Python分别创建对象并范围，因此 c 和 d 对象 id 不同也就不奇怪了。
- 解释以下程序运行结果
```
>>> a1 = b'a'
>>> a2 = b'a'
>>> a1 is a2
True
>>> ab1 = b'ab'
>>> ab2 = b'ab'
>>> ab1 is ab2
False
```
由于**字符缓冲池**的存在，场景⼀第 3 ⾏直接使⽤已缓存的对象，不会重复创建，因此 a1 和 a2
其实是同⼀个对象。**只对单字符有效**。

