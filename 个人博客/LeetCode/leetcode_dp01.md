---
title: LeetCode专题-动态规划I
categories:
- LeetCode 
tags:
- 动态规划
- LeetCode
---
今天准备把自己这段时间在LeetCode上做的一些动态规划的题记录在博文中，首先要说明的是，本篇博文不再细讲有关动态规划的基础知识，而是直接面对一个问题，从重复子问题与最优子结构，状态定义，转移方程，初始状态，输出这几个步骤来解决问题，从而形成一个有效的动态规划刷题模板。话不多啥，让我们开始吧!
<!-- more-->
# 打家劫舍I
## 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
## 最优子结构
对于房屋[2,7,9,3,1]来说，小偷在偷窃的时候，对于每一个房屋都有偷与不偷两种选择，并且小偷当前的选择是受到前面选择的影响，假设f(k)表示小偷从前面k个房子当中偷到的最大值，但是f(k)会受到前面的f(k-1),f(k-2)的影响，因此本题满足动态规划当中的最优子结构条件
## 状态定义
采用dp[i]表示小偷能从前面i个房子中获取到的最大值,num[i]表示当前房屋的价值
## 状态转移方程
* 当小偷选择偷窃第i个房屋的时候，表明第i-1个房间没有被偷窃，此时小偷获取的最大值dp[i] = dp[i-2] + num[i]
* 当小偷选择不偷窃第i个房屋的时候，那么此时可以直接得出dp[i] = dp[i-1]
* 之后取前面两个计算结果的最大值来表示dp[i]即可。
## 初始状态
* 由于此题当中dp[i]仅与i-1 i-2相关，因此可以采用状态空间压缩的方法将O(N)空间减小到O(1)空间 
* dp[0] = 0,dp[1] = num[1]
## 输出结果
* dp[-1]

# 打家劫舍II
## 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
## 最优子结构
本题相对于上面一道题来说，唯一的一个改动来说便是第一个房子是无法和第二个房子同时偷窃到的。
因此我们在解决问题的这道题的时候可以分成两种情况。

* 不偷窃第一个房子，此时最后一个房子可偷也可以不偷，取其结果最大值即可，此时，dp[0]=0,dp[1]=0
* 偷窃第一个房子，此时最后一个房子不可以偷，此时，dp[0]=0,dp[1]=num[1],则此时dp只需计算大dp[n-1]就行。
* 最后取上述两个情况的最大值即可。

# 打家劫舍III
## 题目描述
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
## 最优子结构
本题相对于II来说，直接变成了二叉树结构，对于二叉树结构来说我们依然可以采用DP结构去做，此时的DP变为了树形DP。
## 状态定义
* 使用DP[node][0] 来表示偷取当前节点,使用dp[node][1]来表示不偷取当前节点
## 状态转移方程
* 对于每一个节点来说，计算其左节点dp[left] 和 右节点dp[right]
* 若偷取当前节点，则res = max(left[0],left[1]) + max(right[0],right[1]
* 若不偷取当前节点，则res = node.val + left[0] + right[0]
* 最后取两者当中的最大值即可。
## 初始值
可以看到在树形DO问题当中，并没有看到需要设置初始值的需求。
## 输出结果
输出结果为最后递归的结果

# 爬楼梯
## 题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
## 动态转移方程
此题难度easy，直接得出转移方程f(n)=f(n-1)+f(n-2)，较为简单 略

# 零钱兑换
## 题目描述
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
## 最优子结构
对于本题来说，金币总额amount可以是一个使用最优子结构的的变量。
## 状态定义
定义dp[i]表示凑成金币总额为i所需要的最少的硬币个数
## 状态转移方程
显然对于dp[i] dp[j](i < j)来说 若硬币当中某个面值恰好为i-j,则有dp[i] = min(dp[i],dp[i-j]+1),因此只需遍历一遍硬币即可。
```
for coin in coins:
    if i < coin:
        continue
    dp[i] = min(dp[i],dp[i-coin]+1)
```
## 初始状态
dp[0]=0
## 输出结果
dp[amount+1]

# 剑指offer42连续最大子数组和
## 题目描述
输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。
## 最优子结构
采用滑动窗口的思想来解决本题。
## 状态定义
设动态规划列表为dp，dp[i]代表以元素nums[i]为结尾的连续子数组最大和。
## 状态转移方程
```
if dp < 0:
    dp = nums[i]
else:
    dp = dp + nums[i]
res = max(res,dp)
```
## 初始状态
dp[0] = 0
## 输出结果
max(dp)

# 最佳观光组合
## 题目描述
给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。

一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。

返回一对观光景点能取得的最高分。
## 最优子结构
在此题目中，设 res 为最终结果，dp[i] 为位置i对应的最高分，则有dp[0]=0, dp[1] =A[1] +A[0]-1;
对于i>= 2, dp[i]仅取决于与A[i - 1]的分数和相对于dp[i-1]的景点的分数
## 状态定义
dp[i] 为位置i对应的最高分
## 状态转移方程
在i处，只有两种情况，A[i - 1]被选中和不被选中，选中时为A[i] + A[i-1]-1，不被选中时为dp[i-1]-A[i-1] + A[i]-1，则dp[i]=max(dp[i-1] - A[i-1] + A[i]-1, A[i] + A[i-1]-1);
## 初始值
dp[1] = a[0]+a[1]-1
## 输出结果
max(dp)






