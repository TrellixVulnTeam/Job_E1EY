---
title: LeetCode120-三角形最小路径和
categories:
- LeetCode
tags:
- 动态规划
- LeetCode
---
首先看一下题目描述:
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

例如，给定三角形：

[
     [2],\
    [3,4],\
   [6,5,7],\
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
<!-- more-->
# 题目讲解
这道题用动态规划解起来其实不难，但是当我初次见到这道题的时候，我首先想到的是DFS这类的算法，因为我感觉这个问题不符合动态规划的最优子结构，现在我们就来分析一下这道题是否可以使用动态规划来解决。

首先使用DP(i,j)来表示从顶点到坐标(i,j)的最小路径和。
于是根据移动的性质可知，从顶点到坐标(i,j)的最小路径有两种来源，一种是dp(i-1,j-1)->dp(i,j),另一种时dp(i-1,j),我们可以取两者的最小值再加上traingle(i,j)来表示dp(i,j)的值，因此满足**最优子结构**和**无后效性**这两大动态规划因素。

# 特殊情况分析
当j=0的时候，也就是处在i行0列的时候,此时只能从上一行0列的元素移动过来，此时dp(i-1,j-1)是无效的。

同理j = i的时候，也就是处在i行最后一列的时候，此时只能从上一行j-1列移动过来，此时dp(i-1,j)时无效的。

# 算法优化
- 由于dp(i,j)只和dp(i-1,...)相关，因此可以使用一维数组来代替二位数组。
-  可以看到dp(i,j) = min(dp(i-1,j),dp(i-1,j-1) + traingle(i,j) ),对于同一行的j进行更新时，会产生**覆盖问题**。(计算j=8的时候 8和上一行的7，8有关，计算j=9的时候 9和上一行的8，9有关，但此时8已经被更新。)因此本例采用倒序计算的方法，即计算j = 8的时候，8和7，8有关，此时8更新，计算7的时候，7和6，7有关，不受上一步迭代影响。
- 时间复杂夫:O(n^2) 空间复杂度O(n)

# 代码实现
```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:

        length = len(triangle)
        dp = [0]*length
        dp[0] = triangle[0][0]

        for i in range(1,length):
            #j = i
            dp[i] = dp[i-1] + triangle[i][i]
            #j=1:i-1
            for j in range(i-1,0,-1):
                dp[j] = min(dp[j],dp[j-1]) + triangle[i][j]
            #j =0
            dp[0] += triangle[i][0]
        return min(dp)
```
