from typing import List
'''
动态规划5步曲

第 1 步：定义状态
dp[i][j]：一共有 i 层楼梯（注意：这里 i 不表示高度）的情况下，使用 j 个鸡蛋的最少实验的次数。
说明：
i 表示的是楼层的大小，不是高度（第几层）的意思，例如楼层区间 [8, 9, 10] 的大小为 33。
j 表示可以使用的鸡蛋的个数，它是约束条件。
第一个维度最先容易想到的是表示楼层的高度，这个定义的调整是在状态转移的过程中完成的。因为如果通过实验知道了鸡蛋的 F 值在高度区间 [8, 9, 10] 里，
这个时候只有 1 枚鸡蛋，显然需要做 3 次实验，和区间的大小是相关的。
注意：这里我定义的维度顺序和官方解答的定义是反着的，我个人习惯将约束的那个条件，放置在后面的维度，表示消除后效性的意思。

第 2 步：推导状态转移方程
推导状态转移方程经常做的事情是「分类讨论」，这里「分类讨论」的依据就是，在指定的层数里扔下鸡蛋，根据这个鸡蛋是否破碎，就把问题拆分成了两个子问题。

第 3 步：考虑初始化
一般而言，需要 0 这个状态的值，这里 0 层楼和 0 个鸡蛋是需要考虑进去的，它们的值会被后来的值所参考，并且也比较容易得到。
因此表格需要 N + 1 行，K + 1 列。
由于 F 值不会超过最大楼层的高度，要求的是最小值，因此初始化的时候，可以叫表格的单元格值设置成一个很大的数，但是这个数肯定也不会超过当前考虑的楼层的高度。
第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 F 值，故全为 00；
第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次；
第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 F 值，故全为 00，虽然不符合题意，但是这个值有效，它在后面的计算中会被用到；
第 1 列：鸡蛋个数为 11 的时候，这是一种极端情况，要试出 F 值，最少次数就等于楼层高度；

第 4 步：考虑输出
输出就是表格的最后一个单元格的值 dp[N][K]。

第 5 步：思考状态压缩
看状态转移方程，当前单元格的值只依赖之前的行，当前列和它左边一列的值。可以状态压缩，让「列」滚动起来。但是「状态压缩」的代码增加了理解的难度，我们这里不做。
'''

class Solution:
    #动态规划 超时
    def superEggDrop(self, K: int, N: int) -> int:
        dp = [[i for j in range(K + 1)] for i in range(N + 1)]

        for i in range(K+1):
            dp[0][i] = 0

        for i in range(K+1):
            dp[1][i] = 1 if i > 0 else 0
        
        for i in range(N+1):
            dp[i][0] = 0
            dp[i][1] = i
        
        for i in range(2,N+1):
            for j in range(2,K+1):
                left = 1
                right = i
                while left < right:
                    mid = left + (right-left+1)//2
                    if dp[mid-1][j-1] > dp[i-mid][j]:
                        right = mid-1
                    else:
                        left = mid
                dp[i][j] = max(dp[left-1][j-1],dp[i-left][j])+1

        return dp[N][K]

s = Solution()
print(s.superEggDrop(2,6))
        